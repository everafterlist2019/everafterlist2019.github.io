(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/forms'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('@ng-stack/contenteditable', ['exports', '@angular/forms', '@angular/core'], factory) :
    (factory((global['ng-stack'] = global['ng-stack'] || {}, global['ng-stack'].contenteditable = {}),global.ng.forms,global.ng.core));
}(this, (function (exports,forms,core) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ContenteditableDirective = /** @class */ (function () {
        function ContenteditableDirective(elementRef, renderer) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.propValueAccessor = 'textContent';
            this.contenteditable = true;
        }
        /**
         * @return {?}
         */
        ContenteditableDirective.prototype.callOnChange = /**
         * @return {?}
         */
            function () {
                if (typeof this.onChange == 'function') {
                    this.onChange(this.elementRef.nativeElement[this.propValueAccessor]);
                }
            };
        /**
         * @return {?}
         */
        ContenteditableDirective.prototype.callOnTouched = /**
         * @return {?}
         */
            function () {
                if (typeof this.onTouched == 'function') {
                    this.onTouched();
                }
            };
        /**
         * Writes a new value to the element.
         * This method will be called by the forms API to write
         * to the view when programmatic (model -> view) changes are requested.
         *
         * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)
         */
        /**
         * Writes a new value to the element.
         * This method will be called by the forms API to write
         * to the view when programmatic (model -> view) changes are requested.
         *
         * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)
         * @param {?} value
         * @return {?}
         */
        ContenteditableDirective.prototype.writeValue = /**
         * Writes a new value to the element.
         * This method will be called by the forms API to write
         * to the view when programmatic (model -> view) changes are requested.
         *
         * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var normalizedValue = value == null ? '' : value;
                this.renderer.setProperty(this.elementRef.nativeElement, this.propValueAccessor, normalizedValue);
            };
        /**
         * Registers a callback function that should be called when
         * the control's value changes in the UI.
         *
         * This is called by the forms API on initialization so it can update
         * the form model when values propagate from the view (view -> model).
         */
        /**
         * Registers a callback function that should be called when
         * the control's value changes in the UI.
         *
         * This is called by the forms API on initialization so it can update
         * the form model when values propagate from the view (view -> model).
         * @param {?} fn
         * @return {?}
         */
        ContenteditableDirective.prototype.registerOnChange = /**
         * Registers a callback function that should be called when
         * the control's value changes in the UI.
         *
         * This is called by the forms API on initialization so it can update
         * the form model when values propagate from the view (view -> model).
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        /**
         * Registers a callback function that should be called when the control receives a blur event.
         * This is called by the forms API on initialization so it can update the form model on blur.
         */
        /**
         * Registers a callback function that should be called when the control receives a blur event.
         * This is called by the forms API on initialization so it can update the form model on blur.
         * @param {?} fn
         * @return {?}
         */
        ContenteditableDirective.prototype.registerOnTouched = /**
         * Registers a callback function that should be called when the control receives a blur event.
         * This is called by the forms API on initialization so it can update the form model on blur.
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouched = fn;
            };
        /**
         * This function is called by the forms API when the control status changes to or from "DISABLED".
         * Depending on the value, it should enable or disable the appropriate DOM element.
         */
        /**
         * This function is called by the forms API when the control status changes to or from "DISABLED".
         * Depending on the value, it should enable or disable the appropriate DOM element.
         * @param {?} isDisabled
         * @return {?}
         */
        ContenteditableDirective.prototype.setDisabledState = /**
         * This function is called by the forms API when the control status changes to or from "DISABLED".
         * Depending on the value, it should enable or disable the appropriate DOM element.
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                if (isDisabled) {
                    this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'true');
                    this.removeDisabledState = this.renderer.listen(this.elementRef.nativeElement, 'keydown', this.listenerDisabledState);
                }
                else {
                    if (this.removeDisabledState) {
                        this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');
                        this.removeDisabledState();
                    }
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        ContenteditableDirective.prototype.listenerDisabledState = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                e.preventDefault();
            };
        ContenteditableDirective.decorators = [
            { type: core.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: '[contenteditable]',
                        providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: core.forwardRef(( /**
                                         * @return {?}
                                         */function () { return ContenteditableDirective; })), multi: true }],
                    },] }
        ];
        /** @nocollapse */
        ContenteditableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 }
            ];
        };
        ContenteditableDirective.propDecorators = {
            propValueAccessor: [{ type: core.Input }],
            contenteditable: [{ type: core.HostBinding, args: ['attr.contenteditable',] }, { type: core.Input }],
            callOnChange: [{ type: core.HostListener, args: ['input',] }],
            callOnTouched: [{ type: core.HostListener, args: ['blur',] }]
        };
        return ContenteditableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ContenteditableModule = /** @class */ (function () {
        function ContenteditableModule() {
        }
        ContenteditableModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [ContenteditableDirective],
                        exports: [ContenteditableDirective],
                    },] }
        ];
        return ContenteditableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.ContenteditableDirective = ContenteditableDirective;
    exports.ContenteditableModule = ContenteditableModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ng-stack-contenteditable.umd.js.map